# -*- coding: utf-8 -*-
"""
/***************************************************************************
 HarrisMatrix4QGIS
                                 A QGIS plugin
 Links a Harris Matrix in .graphml to Geometries
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-15
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Brigit Danthine
        email                : brigit.danthine@oeaw.ac.at
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.gui import QgsMapLayerComboBox
from qgis.core import QgsMapLayerProxyModel
from qgis.utils import iface
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .HarrisMatrix4QGIS_dockwidget import HarrisMatrix4QGISDockWidget
import os.path

#import for render_graph:
import networkx as nx 
import matplotlib.pyplot as plt
from xml.etree import ElementTree as ET
from qgis.core import QgsProject
from qgis.core import QgsProject, QgsMapLayer
from networkx.drawing.nx_pydot import graphviz_layout
import numpy as np
from qgis.core import QgsRuleBasedRenderer, QgsSymbol
import qgis._3d
from qgis._3d import QgsPolygon3DSymbol, QgsPhongMaterialSettings, QgsRuleBased3DRenderer
from qgis.PyQt.QtGui import QColor
import re


class HarrisMatrix4QGIS:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'HarrisMatrix4QGIS_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&HarrisMatrix4QGIS')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'HarrisMatrix4QGIS')
        self.toolbar.setObjectName(u'HarrisMatrix4QGIS')

        #print "** INITIALIZING HarrisMatrix4QGIS"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('HarrisMatrix4QGIS', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/harrismatrix4qgis-main/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'HarrisMatrix4QGIS'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING HarrisMatrix4QGIS"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD HarrisMatrix4QGIS"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&HarrisMatrix4QGIS'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def render_graph(self):
        def on_node_click(event, pos, node_attributes):
            if event.inaxes is not None:
                x, y = event.xdata, event.ydata
                for node, attrs in node_attributes.items():
                    nx, ny = attrs["pos"]
                    if (nx - x)**2 + (ny - y)**2 <= 200:  # Klick-Toleranz
                        print("Knoten geklickt:", attrs["label"])
                        selected_node = attrs["label"]
                        selected_SE_number = ""
    
                        if self.dockwidget.trennzeichen_1.isChecked() or self.dockwidget.trennzeichen_2.isChecked():
                            trennzeichen_1 = "-" if self.dockwidget.trennzeichen_1.isChecked() else ""
                            trennzeichen_2 = "_" if self.dockwidget.trennzeichen_2.isChecked() else ""
                            trennzeichen_gesamt = f"[{re.escape(trennzeichen_1)}{re.escape(trennzeichen_2)}]"
    
                            split_selected_node = re.split(trennzeichen_gesamt, selected_node)
                            selected_SE_number = split_selected_node[-1]
                        
                        if len(selected_SE_number) > 0:
                            selected_value = selected_SE_number
                        else:
                            selected_value = selected_node
                        
                        select_feature_by_node_name(selected_value)  # Auswahl-Funktion aufrufen
                        break  
                            
        def select_feature_by_node_name(node_name):
            layer = self.dockwidget.eingabelayer.currentLayer()
            layer.removeSelection()
            select_attribute = self.dockwidget.eingabefeld.currentField()
            exp = "\"{}\" LIKE '%{}%'".format(select_attribute, node_name)
            print("Ausdruck für Attributabfrage:", exp)
            layer.selectByExpression(exp)
        
            # 2D-Symbolisierung aktualisieren (wie bisher)
            renderer_2d = QgsRuleBasedRenderer(QgsSymbol.defaultSymbol(layer.geometryType()))
            root_rule_2d = renderer_2d.rootRule()
        
            selection_rule_2d = QgsRuleBasedRenderer.Rule(symbol=QgsSymbol.defaultSymbol(layer.geometryType()))
            selection_rule_2d.setFilterExpression(exp)
            selection_rule_2d.setLabel("Selection")
        
            root_rule_2d.appendChild(selection_rule_2d)
            layer.setRenderer(renderer_2d)
        
            # 3D-Symbolisierung aktualisieren
            if layer.geometryType() == 0:  # Punkte
                symbol_3d = QgsSimple3DMarkerSymbolLayer()
                material = QgsPhongMaterialSettings()
                rulebase = QgsRuleBased3DRenderer.Rule(symbol_3d)
                rulebase.setActive(False)
                renderer = QgsRuleBased3DRenderer(rulebase)
                root_rule = renderer.rootRule()
                
            elif layer.geometryType() == 1:  # Linien
                symbol_3d = QgsSimple3DLineSymbolLayer()
                material = QgsPhongMaterialSettings()
                rulebase = QgsRuleBased3DRenderer.Rule(symbol_3d)
                rulebase.setActive(False)
                renderer = QgsRuleBased3DRenderer(rulebase)
                root_rule = renderer.rootRule()

            elif layer.geometryType() == 2:  # Polygone
                symbol_3d = QgsPolygon3DSymbol()
                material = QgsPhongMaterialSettings()
                rulebase = QgsRuleBased3DRenderer.Rule(symbol_3d)
                rulebase.setActive(False)
                renderer = QgsRuleBased3DRenderer(rulebase)
                root_rule = renderer.rootRule()

            else:
                return  # Geometrietyp wird nicht unterstützt
        
            def rule_based_style(layer, material, symbol_3d, renderer, label, expression, color):
                material.setAmbient(QColor(color))
                symbol_3d.setMaterialSettings(material)
                symbol_3d.setEdgesEnabled(True)
                
                
                rule = root_rule.clone()
                rule.setDescription(label)
                rule.setFilterExpression(expression)
                
                root_rule.appendChild(rule)
                rule.setActive(True)
                for child in rule.children():
                    rule.removeChildAt(0)
                layer.setRenderer3D(renderer)
                layer.triggerRepaint()
                iface.layerTreeView().refreshLayerSymbology(layer.id())
        
            rule_based_style(layer, material, symbol_3d, renderer, 'Selection', exp, 'red')
            rule_based_style(layer, material, symbol_3d, renderer, 'Anderes', '','black')
            
        #project = QgsProject.instance()
        #su_layer = self.dockwidget.eingabelayer.currentLayer()
        
        def plot_graph_from_graphml(graph_to_load):
            tree = ET.parse(graph_to_load)
            root = tree.getroot()
    
            namespace = "{http://graphml.graphdrawing.org/xmlns}"
            y_namespace = "{http://www.yworks.com/xml/graphml}"
    
            node_attributes = {}
            for node in root.findall(f".//{namespace}node"):
                node_id = node.get("id")
                graphics = node.find(f".//{y_namespace}ShapeNode")
                label_node = node.find(f".//{y_namespace}NodeLabel")
                label = label_node.text if label_node is not None else node_id
    
                if graphics is not None:
                    shape = graphics.find(f".//{y_namespace}Shape")
                    fill = graphics.find(f".//{y_namespace}Fill")
                    border = graphics.find(f".//{y_namespace}BorderStyle")
                    geometry = graphics.find(f".//{y_namespace}Geometry")
    
                    shape_type = shape.get("type", "ellipse") if shape is not None else "ellipse"
                    fill_color = fill.get("color", "lightblue") if fill is not None else "lightblue"
                    border_color = border.get("color", "black") if border is not None else "black"
                    x = float(geometry.get("x", 0)) if geometry is not None else 0
                    y = float(geometry.get("y", 0)) if geometry is not None else 0
                    width = float(geometry.get("width", 30)) if geometry is not None else 30
                    height = float(geometry.get("height", 30)) if geometry is not None else 30
    
                    node_attributes[node_id] = {
                        "shape": shape_type,
                        "fill": fill_color,
                        "border": border_color,
                        "pos": (x + width / 2, -(y + height / 2)),  # Mittelpunkt statt obere Ecke
                        "label": label,
                        "width": width,
                        "height": height
                    }
            return node_attributes
    
        def get_edge_paths(graphml_path):
            tree = ET.parse(graphml_path)
            root = tree.getroot()
            namespace = "{http://graphml.graphdrawing.org/xmlns}"
            y_namespace = "{http://www.yworks.com/xml/graphml}"
    
            edge_paths = {}
            for edge in root.findall(f".//{namespace}edge"):
                source = edge.get("source")
                target = edge.get("target")
                path = []
                polyline = edge.find(f".//{y_namespace}PolyLineEdge/{y_namespace}Path")
                if polyline is not None:
                    for point in polyline.findall(f".//{y_namespace}Point"):
                        x = float(point.get("x", 0))
                        y = float(point.get("y", 0))
                        path.append((x, -y))  # y-Achse invertieren für matplotlib
                edge_paths[(source, target)] = path
            return edge_paths
    
        def draw_graph(graph, node_attributes, edge_paths):
            plt.figure(figsize=(10, 8))
    
            for node, attrs in node_attributes.items():
                x, y = attrs["pos"]
                if attrs["shape"] == "rectangle":
                    plt.gca().add_patch(plt.Rectangle((x - attrs["width"]/2, y - attrs["height"]/2),
                                                    attrs["width"], attrs["height"],
                                                    facecolor=attrs["fill"], edgecolor=attrs["border"], zorder=3))
                else:
                    plt.scatter(x, y, s=700, c=attrs["fill"], edgecolors=attrs["border"], zorder=3)
                plt.text(x, y, attrs["label"], fontsize=8, ha='center', va='center', zorder=4)
    
            for (src, tgt), path in edge_paths.items():
                if src in node_attributes and tgt in node_attributes:
                    x_vals = [node_attributes[src]["pos"][0]] + [p[0] for p in path] + [node_attributes[tgt]["pos"][0]]
                    y_vals = [node_attributes[src]["pos"][1]] + [p[1] for p in path] + [node_attributes[tgt]["pos"][1]]
    
                    plt.plot(x_vals, y_vals, color='gray', linestyle='-', linewidth=1, zorder=2)
                    if len(x_vals) > 1 and len(y_vals) > 1:
                        plt.arrow(x_vals[-2], y_vals[-2], x_vals[-1] - x_vals[-2], y_vals[-1] - y_vals[-2],
                                head_width=5, head_length=10, fc='gray', ec='gray', length_includes_head=True, zorder=3)
    
            plt.axis('off')
            plt.show()
    
        graph_to_load = self.dockwidget.input_graphml.filePath()
        node_attributes = plot_graph_from_graphml(graph_to_load)
        edge_paths = get_edge_paths(graph_to_load)
        draw_graph(nx.Graph(), node_attributes, edge_paths)
    
        pos_array = {node_id: np.array(attrs["pos"]) for node_id, attrs in node_attributes.items()}
        plt.gcf().canvas.mpl_connect('button_press_event', lambda event: on_node_click(event, pos_array, node_attributes))
    
    
    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True
            #self.dlg = HarrisMatrix4QGISDockWidget()
            #print "** STARTING HarrisMatrix4QGIS"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = HarrisMatrix4QGISDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            
            self.dockwidget.eingabelayer.setFilters(QgsMapLayerProxyModel.VectorLayer)
            self.dockwidget.eingabelayer.layerChanged.connect(self.dockwidget.eingabefeld.setLayer)
            
            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            
            self.dockwidget.start.clicked.connect(self.render_graph)

